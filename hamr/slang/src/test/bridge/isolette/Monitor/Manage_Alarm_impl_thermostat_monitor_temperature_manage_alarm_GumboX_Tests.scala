package isolette.Monitor

import org.sireum._
import isolette.Monitor._
import isolette.GumboXUtil
import isolette.GumboXUtil.GumboXResult
import isolette.RandomLib
import org.sireum.Random.Gen64
import org.sireum.Random.Impl.Xoshiro256

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
trait Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_GumboX_Tests extends Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_GumboX_TestHarness_ScalaTest {

  // set failOnUnsatPreconditions to T if the unit tests should fail when either
  // SlangCheck is never able to satisfy a datatype's filter or the generated
  // test vectors are never able to satisfy an entry point's assume pre-condition
  var failOnUnsatPreconditions: B = F

  def getDefaultProfile_P: MA_Profile_P = {
    return MA_Profile_P(
      name = "Default Port Profile",
      api_current_tempWstatus = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_lower_alarm_temp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_monitor_mode = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_upper_alarm_temp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
    )
  }

  def getDefaultProfile_PS: MA_Profile_PS = {
    return MA_Profile_PS(
      name = "Default Port and State Variable Profile",
      In_lastCmd = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_current_tempWstatus = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_lower_alarm_temp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_monitor_mode = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))),
      api_upper_alarm_temp = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))
    )
  }

  def getProfiles_P: MSZ[MA_Profile_P]
  def getProfiles_PS: MSZ[MA_Profile_PS]

  val seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)

  def next(profile: MA_Profile): Option[Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_P] = {
    try {
      val api_current_tempWstatus = profile.api_current_tempWstatus.nextIsolette_Data_ModelTempWstatus_impl()
      val api_lower_alarm_temp = profile.api_lower_alarm_temp.nextIsolette_Data_ModelTemp_impl()
      val api_monitor_mode = profile.api_monitor_mode.nextIsolette_Data_ModelMonitor_ModeType()
      val api_upper_alarm_temp = profile.api_upper_alarm_temp.nextIsolette_Data_ModelTemp_impl()

      return Some(Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_P(api_current_tempWstatus,api_lower_alarm_temp,api_monitor_mode,api_upper_alarm_temp))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  def nextwL(profile: MA_Profile_PS): Option[Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_PS] = {
    try {
      val In_lastCmd = profile.In_lastCmd.nextIsolette_Data_ModelOn_OffType()
      val api_current_tempWstatus = profile.api_current_tempWstatus.nextIsolette_Data_ModelTempWstatus_impl()
      val api_lower_alarm_temp = profile.api_lower_alarm_temp.nextIsolette_Data_ModelTemp_impl()
      val api_monitor_mode = profile.api_monitor_mode.nextIsolette_Data_ModelMonitor_ModeType()
      val api_upper_alarm_temp = profile.api_upper_alarm_temp.nextIsolette_Data_ModelTemp_impl()

      return Some(Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_PS(In_lastCmd,api_current_tempWstatus,api_lower_alarm_temp,api_monitor_mode,api_upper_alarm_temp))
    } catch {
      case e: AssertionError =>
       // SlangCheck was unable to satisfy a datatype's filter
       return None()
    }
  }

  {
    for (i <- 0 to GumboXUtil.numTests) {
      this.registerTest(s"testInitialiseCB_$i") {
        testInitialiseCB() match {
          case GumboXResult.Pre_Condition_Unsat =>
            halt("Infeasible as initialize entry points cannot contain assume clauses and cannot access incoming ports or state variables")
          case GumboXResult.Post_Condition_Fail =>
            fail ("Post condition did not hold")
          case GumboXResult.Post_Condition_Pass =>
            if (verbose) {
              println ("Success!")
            }
        }
      }
    }
  }


  { // new codegen addition that runs all the profiles for testComputeCB
    for (profile <- getProfiles_P) {
      profileTestComputeCB(profile)
    }
  }


  def profileTestComputeCB(profile: MA_Profile): Unit = {
    for (i <- 0 to GumboXUtil.numTests) {
      this.registerTest(s"Profile \"${profile.name}\": testComputeCB_$i") {
        var retry: B = T

        var j: Z = 0
        while (j < GumboXUtil.numTestVectorGenRetries && retry) {
          next(profile) match {
            case Some(o) =>

              if (verbose && j > 0) {
                println(s"Retry $j:")
              }

              val results = testComputeCBV(o)

              if (verbose) {
                val tq = "\"\"\""
                println(
                  st"""Replay Unit Test:
                      |  test("Replay testComputeCB_$i") {
                      |    val json = st${tq}${isolette.JSON.fromMonitorManage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_P(o, T)}${tq}.render
                      |    val testVector = isolette.JSON.toMonitorManage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_P(json).left
                      |    assert (testComputeCBV(testVector) == isolette.GumboXUtil.GumboXResult.$results)
                      |  }""".render)
              }

              results match {
                case GumboXResult.Pre_Condition_Unsat =>
                case GumboXResult.Post_Condition_Fail =>
                  fail("Post condition did not hold")
                  retry = F
                case GumboXResult.Post_Condition_Pass =>
                  if (verbose) {
                    println("Success!")
                  }
                  retry = F
              }
            case _ =>
          }
          j = j + 1
        }

        if (retry) {
          if (failOnUnsatPreconditions) {
            fail("Unable to satisfy precondition")
          } else if (verbose) {
            cprintln(T, "Unable to satisfy precondition")
          }
        }
      }
    }
  }





  {
    var pindex = 0
    for (profile <- getProfiles_PS) {
      for (i <- 0 to GumboXUtil.numTests) {
        this.registerTest(s"Profile $pindex \"${profile.name}\": testComputeCBwL_$i") {
          var retry: B = T

          var j: Z = 0
          while (j < GumboXUtil.numTestVectorGenRetries && retry) {
            nextwL(profile) match {
              case Some(o) =>

                if (verbose && j > 0) {
                  println(s"Retry $j:")
                }

                val results = testComputeCBwLV(o)

                if (verbose) {
                  val tq = "\"\"\""
                  println(
                    st"""Replay Unit Test:
                        |  test("Replay testComputeCBwL_$i") {
                        |    val json = st${tq}${isolette.JSON.fromMonitorManage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_PS(o, T)}${tq}.render
                        |    val testVector = isolette.JSON.toMonitorManage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_PreState_Container_PS(json).left
                        |    assert (testComputeCBwLV(testVector) == isolette.GumboXUtil.GumboXResult.$results)
                        |  }""".render)
                }

                results match {
                  case GumboXResult.Pre_Condition_Unsat =>
                  case GumboXResult.Post_Condition_Fail =>
                    fail("Post condition did not hold")
                    retry = F
                  case GumboXResult.Post_Condition_Pass =>
                    if (verbose) {
                      println("Success!")
                    }
                    retry = F
                }
              case _ =>
            }
            j = j + 1
          }

          if (retry) {
            if (failOnUnsatPreconditions) {
              fail("Unable to satisfy precondition")
            } else if (verbose) {
              cprintln(T, "Unable to satisfy precondition")
            }
          }
        }
      }
    }
    pindex = pindex + 1
  }
}